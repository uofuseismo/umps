<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UMPS: UMPS::Messaging::SocketOptions Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UMPS
   </div>
   <div id="projectbrief">The University of Utah Seismograph Stations Message Passing System.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_u_m_p_s_1_1_messaging_1_1_socket_options.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="class_u_m_p_s_1_1_messaging_1_1_socket_options-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UMPS::Messaging::SocketOptions Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a base class for setting socket options.  
 <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="socket_options_8hpp_source.html">umps/messaging/socketOptions.hpp</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a4ea0d81e747a87d710331267f7b19e00"><td class="memItemLeft" align="right" valign="top"><a id="a4ea0d81e747a87d710331267f7b19e00"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a4ea0d81e747a87d710331267f7b19e00">SocketOptions</a> ()</td></tr>
<tr class="memdesc:a4ea0d81e747a87d710331267f7b19e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a4ea0d81e747a87d710331267f7b19e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e9b6ba1d5c0b0bdefb4531f268b83f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#ad9e9b6ba1d5c0b0bdefb4531f268b83f">SocketOptions</a> (const <a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a> &amp;options)</td></tr>
<tr class="memdesc:ad9e9b6ba1d5c0b0bdefb4531f268b83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#ad9e9b6ba1d5c0b0bdefb4531f268b83f">More...</a><br /></td></tr>
<tr class="separator:ad9e9b6ba1d5c0b0bdefb4531f268b83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0e16f15cf4f0a0285af9eab7e4f183"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a7f0e16f15cf4f0a0285af9eab7e4f183">SocketOptions</a> (<a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a> &amp;&amp;options) noexcept</td></tr>
<tr class="memdesc:a7f0e16f15cf4f0a0285af9eab7e4f183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a7f0e16f15cf4f0a0285af9eab7e4f183">More...</a><br /></td></tr>
<tr class="separator:a7f0e16f15cf4f0a0285af9eab7e4f183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:a34c85c4c3f0f662b46ec7d17b515a368"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a34c85c4c3f0f662b46ec7d17b515a368">operator=</a> (const <a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a> &amp;options)</td></tr>
<tr class="memdesc:a34c85c4c3f0f662b46ec7d17b515a368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a34c85c4c3f0f662b46ec7d17b515a368">More...</a><br /></td></tr>
<tr class="separator:a34c85c4c3f0f662b46ec7d17b515a368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab441ec361e1ff77287dcaf9f713367f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#ab441ec361e1ff77287dcaf9f713367f8">operator=</a> (<a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a> &amp;&amp;options) noexcept</td></tr>
<tr class="separator:ab441ec361e1ff77287dcaf9f713367f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Address (Required)</div></td></tr>
<tr class="memitem:aca4f7df056f95c714dbd28591cee8d6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#aca4f7df056f95c714dbd28591cee8d6f">setAddress</a> (const std::string &amp;address)</td></tr>
<tr class="memdesc:aca4f7df056f95c714dbd28591cee8d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the address to which to bind or connect the socket.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#aca4f7df056f95c714dbd28591cee8d6f">More...</a><br /></td></tr>
<tr class="separator:aca4f7df056f95c714dbd28591cee8d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b81d59b88d416a1f53df8609fb9280"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#ac5b81d59b88d416a1f53df8609fb9280">getAddress</a> () const</td></tr>
<tr class="separator:ac5b81d59b88d416a1f53df8609fb9280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5924274da9a0bef819cd201a6eff7a78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a5924274da9a0bef819cd201a6eff7a78">haveAddress</a> () const noexcept</td></tr>
<tr class="separator:a5924274da9a0bef819cd201a6eff7a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ZeroMQ Authentication Protocol</div></td></tr>
<tr class="memitem:a59f8fe2e3cd6c57c7e436beeab44640b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a59f8fe2e3cd6c57c7e436beeab44640b">setZAPOptions</a> (const <a class="el" href="class_u_m_p_s_1_1_authentication_1_1_z_a_p_options.html">Authentication::ZAPOptions</a> &amp;options) noexcept</td></tr>
<tr class="memdesc:a59f8fe2e3cd6c57c7e436beeab44640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ZAP options.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a59f8fe2e3cd6c57c7e436beeab44640b">More...</a><br /></td></tr>
<tr class="separator:a59f8fe2e3cd6c57c7e436beeab44640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f610cf43a58fd7cd3e9b820533e172"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_u_m_p_s_1_1_authentication_1_1_z_a_p_options.html">Authentication::ZAPOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a31f610cf43a58fd7cd3e9b820533e172">getZAPOptions</a> () const noexcept</td></tr>
<tr class="separator:a31f610cf43a58fd7cd3e9b820533e172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Callback</div></td></tr>
<tr class="memitem:a430ba445368e9a78de61ca3dd65af74f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a430ba445368e9a78de61ca3dd65af74f">setCallback</a> (const std::function&lt; std::unique_ptr&lt; <a class="el" href="class_u_m_p_s_1_1_message_formats_1_1_i_message.html">UMPS::MessageFormats::IMessage</a> &gt;(const std::string &amp;messageType, const void *data, size_t length)&gt; &amp;callback)</td></tr>
<tr class="memdesc:a430ba445368e9a78de61ca3dd65af74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the generic request-reply pattern a socket will take action after a message is received. In this case, the received message will be processed and responded to by this function.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a430ba445368e9a78de61ca3dd65af74f">More...</a><br /></td></tr>
<tr class="separator:a430ba445368e9a78de61ca3dd65af74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d85d62ddbe83c296a62ea8ec4e42cd"><td class="memItemLeft" align="right" valign="top">std::function&lt; std::unique_ptr&lt; <a class="el" href="class_u_m_p_s_1_1_message_formats_1_1_i_message.html">UMPS::MessageFormats::IMessage</a> &gt;const std::string &amp;messageType, const void *data, size_t length)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#ab0d85d62ddbe83c296a62ea8ec4e42cd">getCallback</a> () const</td></tr>
<tr class="separator:ab0d85d62ddbe83c296a62ea8ec4e42cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ab1dbab3b5cf12063bdaa264a20b83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a67ab1dbab3b5cf12063bdaa264a20b83">haveCallback</a> () const noexcept</td></tr>
<tr class="separator:a67ab1dbab3b5cf12063bdaa264a20b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Message Formats</div></td></tr>
<tr class="memitem:a0599f60f95294c9a31086bb6bad87b8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a0599f60f95294c9a31086bb6bad87b8e">setMessageFormats</a> (const <a class="el" href="class_u_m_p_s_1_1_message_formats_1_1_messages.html">UMPS::MessageFormats::Messages</a> &amp;messageFormats)</td></tr>
<tr class="memdesc:a0599f60f95294c9a31086bb6bad87b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the messages formats that will be converted from ZMQ messages to IMessages. This is only necessary for sockets that intend to receive messages and are not using a callback function to process those messages.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a0599f60f95294c9a31086bb6bad87b8e">More...</a><br /></td></tr>
<tr class="separator:a0599f60f95294c9a31086bb6bad87b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add64ecd4af8a3a3be277d1803927574e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_u_m_p_s_1_1_message_formats_1_1_messages.html">UMPS::MessageFormats::Messages</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#add64ecd4af8a3a3be277d1803927574e">getMessageFormats</a> () const</td></tr>
<tr class="separator:add64ecd4af8a3a3be277d1803927574e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8c12443dfb98e2da62266a615bebed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a9f8c12443dfb98e2da62266a615bebed">haveMessageFormats</a> () const noexcept</td></tr>
<tr class="separator:a9f8c12443dfb98e2da62266a615bebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Time Out</div></td></tr>
<tr class="memitem:a64810926fdc8b54d95b11167a4f120b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a64810926fdc8b54d95b11167a4f120b2">setReceiveTimeOut</a> (const std::chrono::milliseconds &amp;timeOut) noexcept</td></tr>
<tr class="memdesc:a64810926fdc8b54d95b11167a4f120b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this amount of time ellapses before a message is received then the receive message call will return without message. This is useful when the receiving thread has other responsibilities.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a64810926fdc8b54d95b11167a4f120b2">More...</a><br /></td></tr>
<tr class="separator:a64810926fdc8b54d95b11167a4f120b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2170b151438ceeab50de293caf7f89b9"><td class="memItemLeft" align="right" valign="top">std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a2170b151438ceeab50de293caf7f89b9">getReceiveTimeOut</a> () const noexcept</td></tr>
<tr class="separator:a2170b151438ceeab50de293caf7f89b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966ac9817d9f8a764adc8477dd4688a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a966ac9817d9f8a764adc8477dd4688a0">setSendTimeOut</a> (const std::chrono::milliseconds &amp;timeOut) noexcept</td></tr>
<tr class="memdesc:a966ac9817d9f8a764adc8477dd4688a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this amount of time ellapses before a message is sent then the send message call will return without sending the message. This is useful when the requestor thread has other responsibilities and the application has, potentially, lost connectivity.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a966ac9817d9f8a764adc8477dd4688a0">More...</a><br /></td></tr>
<tr class="separator:a966ac9817d9f8a764adc8477dd4688a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c49792e8461e0aaafd9fc77b80c2470"><td class="memItemLeft" align="right" valign="top">std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a8c49792e8461e0aaafd9fc77b80c2470">getSendTimeOut</a> () const noexcept</td></tr>
<tr class="separator:a8c49792e8461e0aaafd9fc77b80c2470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4706d5d9f63a07cdf3e397325a42feab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a4706d5d9f63a07cdf3e397325a42feab">setPollingTimeOut</a> (const std::chrono::milliseconds &amp;timeOut)</td></tr>
<tr class="memdesc:a4706d5d9f63a07cdf3e397325a42feab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polling thread is contained in a while loop that runs until the service is terminated. The polling thread will wait this amount of time for a request before proceeding.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a4706d5d9f63a07cdf3e397325a42feab">More...</a><br /></td></tr>
<tr class="separator:a4706d5d9f63a07cdf3e397325a42feab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6099476d3c3efeb46e3d7762a6f5b46f"><td class="memItemLeft" align="right" valign="top">std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a6099476d3c3efeb46e3d7762a6f5b46f">getPollingTimeOut</a> () const noexcept</td></tr>
<tr class="separator:a6099476d3c3efeb46e3d7762a6f5b46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Routing Identifier</div></td></tr>
<tr class="memitem:ac0b79d75a7a6c5999f881ec909e5b860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#ac0b79d75a7a6c5999f881ec909e5b860">setRoutingIdentifier</a> (const std::string &amp;identifier)</td></tr>
<tr class="memdesc:ac0b79d75a7a6c5999f881ec909e5b860"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides a way for a socket to identify itself for the benefit of a proxy that must route messages to specific endpoints. For most applications this is not required and you should let ZeroMQ automatically populate this information.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#ac0b79d75a7a6c5999f881ec909e5b860">More...</a><br /></td></tr>
<tr class="separator:ac0b79d75a7a6c5999f881ec909e5b860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04030bcf13edcc12077bb94ad0be0401"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a04030bcf13edcc12077bb94ad0be0401">getRoutingIdentifier</a> () const</td></tr>
<tr class="separator:a04030bcf13edcc12077bb94ad0be0401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff2e42eeb2a49065b8dab3a54372a5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a8ff2e42eeb2a49065b8dab3a54372a5b">haveRoutingIdentifier</a> () const noexcept</td></tr>
<tr class="separator:a8ff2e42eeb2a49065b8dab3a54372a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">High Water Mark</div></td></tr>
<tr class="memitem:a1092071a0a050c565cd6b4e1f86e2b10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a1092071a0a050c565cd6b4e1f86e2b10">setSendHighWaterMark</a> (int highWaterMark)</td></tr>
<tr class="memdesc:a1092071a0a050c565cd6b4e1f86e2b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets a hard limit on the maximum number of messages that can be queued for sending.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a1092071a0a050c565cd6b4e1f86e2b10">More...</a><br /></td></tr>
<tr class="separator:a1092071a0a050c565cd6b4e1f86e2b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922fdab4707569bf32b6bc3fdb5530e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a922fdab4707569bf32b6bc3fdb5530e7">getSendHighWaterMark</a> () const noexcept</td></tr>
<tr class="separator:a922fdab4707569bf32b6bc3fdb5530e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae428c7a07413823359d5f7f722f4b824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#ae428c7a07413823359d5f7f722f4b824">setReceiveHighWaterMark</a> (int highWaterMark)</td></tr>
<tr class="memdesc:ae428c7a07413823359d5f7f722f4b824"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sets a hard limit on the maximum number of messages that can be queued for receiving.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#ae428c7a07413823359d5f7f722f4b824">More...</a><br /></td></tr>
<tr class="separator:ae428c7a07413823359d5f7f722f4b824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc721bde96f436fcf55ce8775e7acde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#acdc721bde96f436fcf55ce8775e7acde">getReceiveHighWaterMark</a> () const noexcept</td></tr>
<tr class="separator:acdc721bde96f436fcf55ce8775e7acde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Linger Period</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>{ </p>
</div></td></tr>
<tr class="memitem:a83e1808b73bc54d32d6941a21a80a5b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a83e1808b73bc54d32d6941a21a80a5b8">setLingerPeriod</a> (const std::chrono::milliseconds &amp;period) noexcept</td></tr>
<tr class="memdesc:a83e1808b73bc54d32d6941a21a80a5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the behavior of a socket when the socket is closed and there still exist unsent messages.  <a href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a83e1808b73bc54d32d6941a21a80a5b8">More...</a><br /></td></tr>
<tr class="separator:a83e1808b73bc54d32d6941a21a80a5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5feb355e41f742616dddc495fe36825"><td class="memItemLeft" align="right" valign="top">std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#aa5feb355e41f742616dddc495fe36825">getLingerPeriod</a> () const noexcept</td></tr>
<tr class="separator:aa5feb355e41f742616dddc495fe36825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructors</div></td></tr>
<tr class="memitem:aa3b4ceae86e0721ed341c7beaa077e7f"><td class="memItemLeft" align="right" valign="top"><a id="aa3b4ceae86e0721ed341c7beaa077e7f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#aa3b4ceae86e0721ed341c7beaa077e7f">clear</a> () noexcept</td></tr>
<tr class="memdesc:aa3b4ceae86e0721ed341c7beaa077e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the class and releases memory. <br /></td></tr>
<tr class="separator:aa3b4ceae86e0721ed341c7beaa077e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb03661b97098889fd1417a05f72b1a1"><td class="memItemLeft" align="right" valign="top"><a id="acb03661b97098889fd1417a05f72b1a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#acb03661b97098889fd1417a05f72b1a1">~SocketOptions</a> ()</td></tr>
<tr class="memdesc:acb03661b97098889fd1417a05f72b1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:acb03661b97098889fd1417a05f72b1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a base class for setting socket options. </p>
<dl class="section note"><dt>Note</dt><dd>Not all options are implemented in all socket types. <br  />
 It is recommended that you use the the appropriate socket's details instead of this class. </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Ben Baker (University of Utah) distributed under the MIT license. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad9e9b6ba1d5c0b0bdefb4531f268b83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e9b6ba1d5c0b0bdefb4531f268b83f">&#9670;&nbsp;</a></span>SocketOptions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UMPS::Messaging::SocketOptions::SocketOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>The options class from which to initialize this class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f0e16f15cf4f0a0285af9eab7e4f183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0e16f15cf4f0a0285af9eab7e4f183">&#9670;&nbsp;</a></span>SocketOptions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UMPS::Messaging::SocketOptions::SocketOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">options</td><td>The options class from which to initialize this class. On exit options's behavior is undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac5b81d59b88d416a1f53df8609fb9280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b81d59b88d416a1f53df8609fb9280">&#9670;&nbsp;</a></span>getAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string UMPS::Messaging::SocketOptions::getAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The address to which to bind or connect this socket. </dd></dl>

</div>
</div>
<a id="ab0d85d62ddbe83c296a62ea8ec4e42cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d85d62ddbe83c296a62ea8ec4e42cd">&#9670;&nbsp;</a></span>getCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;std::unique_ptr&lt;<a class="el" href="class_u_m_p_s_1_1_message_formats_1_1_i_message.html">UMPS::MessageFormats::IMessage</a>&gt;const std::string &amp;messageType, const void *data, size_t length)&gt; UMPS::Messaging::SocketOptions::getCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The callback function. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a67ab1dbab3b5cf12063bdaa264a20b83">haveCallback()</a></code> is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5feb355e41f742616dddc495fe36825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5feb355e41f742616dddc495fe36825">&#9670;&nbsp;</a></span>getLingerPeriod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::milliseconds UMPS::Messaging::SocketOptions::getLingerPeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The linger period. By default this is -1 (infinite). </dd></dl>

</div>
</div>
<a id="add64ecd4af8a3a3be277d1803927574e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add64ecd4af8a3a3be277d1803927574e">&#9670;&nbsp;</a></span>getMessageFormats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_u_m_p_s_1_1_message_formats_1_1_messages.html">UMPS::MessageFormats::Messages</a> UMPS::Messaging::SocketOptions::getMessageFormats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The message formats that can be deserialized into a class. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a9f8c12443dfb98e2da62266a615bebed">haveMessageFormats()</a></code> is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6099476d3c3efeb46e3d7762a6f5b46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6099476d3c3efeb46e3d7762a6f5b46f">&#9670;&nbsp;</a></span>getPollingTimeOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::milliseconds UMPS::Messaging::SocketOptions::getPollingTimeOut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The amount of time a polling thread will wait before proceeding to other activities. </dd></dl>

</div>
</div>
<a id="acdc721bde96f436fcf55ce8775e7acde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc721bde96f436fcf55ce8775e7acde">&#9670;&nbsp;</a></span>getReceiveHighWaterMark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int UMPS::Messaging::SocketOptions::getReceiveHighWaterMark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The high water mark. The default is 0 (infinite). </dd></dl>

</div>
</div>
<a id="a2170b151438ceeab50de293caf7f89b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2170b151438ceeab50de293caf7f89b9">&#9670;&nbsp;</a></span>getReceiveTimeOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::milliseconds UMPS::Messaging::SocketOptions::getReceiveTimeOut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The time out duration in milliseconds. </dd></dl>

</div>
</div>
<a id="a04030bcf13edcc12077bb94ad0be0401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04030bcf13edcc12077bb94ad0be0401">&#9670;&nbsp;</a></span>getRoutingIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string UMPS::Messaging::SocketOptions::getRoutingIdentifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The routing identifier. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html#a8ff2e42eeb2a49065b8dab3a54372a5b">haveRoutingIdentifier()</a></code> is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a922fdab4707569bf32b6bc3fdb5530e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922fdab4707569bf32b6bc3fdb5530e7">&#9670;&nbsp;</a></span>getSendHighWaterMark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int UMPS::Messaging::SocketOptions::getSendHighWaterMark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The high water mark. The default is 0 (infinite). </dd></dl>

</div>
</div>
<a id="a8c49792e8461e0aaafd9fc77b80c2470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c49792e8461e0aaafd9fc77b80c2470">&#9670;&nbsp;</a></span>getSendTimeOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::milliseconds UMPS::Messaging::SocketOptions::getSendTimeOut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The time out duration in milliseconds. </dd></dl>

</div>
</div>
<a id="a31f610cf43a58fd7cd3e9b820533e172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f610cf43a58fd7cd3e9b820533e172">&#9670;&nbsp;</a></span>getZAPOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_u_m_p_s_1_1_authentication_1_1_z_a_p_options.html">Authentication::ZAPOptions</a> UMPS::Messaging::SocketOptions::getZAPOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The ZAP options. </dd></dl>

</div>
</div>
<a id="a5924274da9a0bef819cd201a6eff7a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5924274da9a0bef819cd201a6eff7a78">&#9670;&nbsp;</a></span>haveAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UMPS::Messaging::SocketOptions::haveAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True indicates the address was set. </dd></dl>

</div>
</div>
<a id="a67ab1dbab3b5cf12063bdaa264a20b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ab1dbab3b5cf12063bdaa264a20b83">&#9670;&nbsp;</a></span>haveCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UMPS::Messaging::SocketOptions::haveCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True indicates the callback was set. </dd></dl>

</div>
</div>
<a id="a9f8c12443dfb98e2da62266a615bebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8c12443dfb98e2da62266a615bebed">&#9670;&nbsp;</a></span>haveMessageFormats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UMPS::Messaging::SocketOptions::haveMessageFormats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True indicates that message formats were set. </dd></dl>

</div>
</div>
<a id="a8ff2e42eeb2a49065b8dab3a54372a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff2e42eeb2a49065b8dab3a54372a5b">&#9670;&nbsp;</a></span>haveRoutingIdentifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UMPS::Messaging::SocketOptions::haveRoutingIdentifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True indicates the routing identifier was set. </dd></dl>

</div>
</div>
<a id="a34c85c4c3f0f662b46ec7d17b515a368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c85c4c3f0f662b46ec7d17b515a368">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a>&amp; UMPS::Messaging::SocketOptions::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>A deep copy of the input options. </dd></dl>

</div>
</div>
<a id="ab441ec361e1ff77287dcaf9f713367f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab441ec361e1ff77287dcaf9f713367f8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a>&amp; UMPS::Messaging::SocketOptions::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The memory from options moved to this. </dd></dl>

</div>
</div>
<a id="aca4f7df056f95c714dbd28591cee8d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4f7df056f95c714dbd28591cee8d6f">&#9670;&nbsp;</a></span>setAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UMPS::Messaging::SocketOptions::setAddress </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the address to which to bind or connect the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address to which to bind or connect this socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the protocol is not supported or the address is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a430ba445368e9a78de61ca3dd65af74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430ba445368e9a78de61ca3dd65af74f">&#9670;&nbsp;</a></span>setCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UMPS::Messaging::SocketOptions::setCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::unique_ptr&lt; <a class="el" href="class_u_m_p_s_1_1_message_formats_1_1_i_message.html">UMPS::MessageFormats::IMessage</a> &gt;(const std::string &amp;messageType, const void *data, size_t length)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the generic request-reply pattern a socket will take action after a message is received. In this case, the received message will be processed and responded to by this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback function which processes the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is important this function never throw, crash, etc. This is when exiting gracefully matters. </dd></dl>

</div>
</div>
<a id="a83e1808b73bc54d32d6941a21a80a5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e1808b73bc54d32d6941a21a80a5b8">&#9670;&nbsp;</a></span>setLingerPeriod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UMPS::Messaging::SocketOptions::setLingerPeriod </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the behavior of a socket when the socket is closed and there still exist unsent messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>The linger period. If this is negative then the pending messages will not be discarded after the socket is closed. If this is 0 then unsent messages will be immediately discarded when the socket is closed. If this is positive then unsent messages possibly will be sent during this time. However, if this time is reached then unsent messages will be discarded. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0599f60f95294c9a31086bb6bad87b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0599f60f95294c9a31086bb6bad87b8e">&#9670;&nbsp;</a></span>setMessageFormats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UMPS::Messaging::SocketOptions::setMessageFormats </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_u_m_p_s_1_1_message_formats_1_1_messages.html">UMPS::MessageFormats::Messages</a> &amp;&#160;</td>
          <td class="paramname"><em>messageFormats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the messages formats that will be converted from ZMQ messages to IMessages. This is only necessary for sockets that intend to receive messages and are not using a callback function to process those messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">messageFormats</td><td>The message formats to unpack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if messageFormats is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4706d5d9f63a07cdf3e397325a42feab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4706d5d9f63a07cdf3e397325a42feab">&#9670;&nbsp;</a></span>setPollingTimeOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UMPS::Messaging::SocketOptions::setPollingTimeOut </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>timeOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A polling thread is contained in a while loop that runs until the service is terminated. The polling thread will wait this amount of time for a request before proceeding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeOut</td><td>The amount of time for a polling thread will wait for a message before proceeding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if this is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae428c7a07413823359d5f7f722f4b824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae428c7a07413823359d5f7f722f4b824">&#9670;&nbsp;</a></span>setReceiveHighWaterMark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UMPS::Messaging::SocketOptions::setReceiveHighWaterMark </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>highWaterMark</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This sets a hard limit on the maximum number of messages that can be queued for receiving. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">highWaterMark</td><td>The high limit on the maximum number of messages that this socket can queue. 0 sets this to "infinite." <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the high water mark is negative. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64810926fdc8b54d95b11167a4f120b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64810926fdc8b54d95b11167a4f120b2">&#9670;&nbsp;</a></span>setReceiveTimeOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UMPS::Messaging::SocketOptions::setReceiveTimeOut </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>timeOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this amount of time ellapses before a message is received then the receive message call will return without message. This is useful when the receiving thread has other responsibilities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeOut</td><td>The receive time out duration in milliseconds. If this is zero then the requestor will immediately return. If this is negative then the requestor will wait indefinitely until a message is received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0b79d75a7a6c5999f881ec909e5b860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b79d75a7a6c5999f881ec909e5b860">&#9670;&nbsp;</a></span>setRoutingIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UMPS::Messaging::SocketOptions::setRoutingIdentifier </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This provides a way for a socket to identify itself for the benefit of a proxy that must route messages to specific endpoints. For most applications this is not required and you should let ZeroMQ automatically populate this information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">identifier</td><td>The socket identifier. If identifier.size() exceeds 255 then it will be truncated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1092071a0a050c565cd6b4e1f86e2b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1092071a0a050c565cd6b4e1f86e2b10">&#9670;&nbsp;</a></span>setSendHighWaterMark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UMPS::Messaging::SocketOptions::setSendHighWaterMark </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>highWaterMark</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This sets a hard limit on the maximum number of messages that can be queued for sending. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">highWaterMark</td><td>The high limit on the maximum number of messages that this socket can queue. 0 sets this to "infinite." <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the high water mark is negative. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a966ac9817d9f8a764adc8477dd4688a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966ac9817d9f8a764adc8477dd4688a0">&#9670;&nbsp;</a></span>setSendTimeOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UMPS::Messaging::SocketOptions::setSendTimeOut </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>timeOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this amount of time ellapses before a message is sent then the send message call will return without sending the message. This is useful when the requestor thread has other responsibilities and the application has, potentially, lost connectivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeOut</td><td>The send time out duration in milliseconds. If this is zero then the sender will immediately return. If this is negative then the sender will wait indefinitely until the message is sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59f8fe2e3cd6c57c7e436beeab44640b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f8fe2e3cd6c57c7e436beeab44640b">&#9670;&nbsp;</a></span>setZAPOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UMPS::Messaging::SocketOptions::setZAPOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_u_m_p_s_1_1_authentication_1_1_z_a_p_options.html">Authentication::ZAPOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the ZAP options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>The ZAP options which will define the socket's security protocol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/umps/messaging/<a class="el" href="socket_options_8hpp_source.html">socketOptions.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>UMPS</b></li><li class="navelem"><b>Messaging</b></li><li class="navelem"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_socket_options.html">SocketOptions</a></li>
    <li class="footer">Generated on Thu Jan 12 2023 16:27:18 for UMPS by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
