<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UMPS: Extended Publisher-Subscriber</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UMPS
   </div>
   <div id="projectbrief">The University of Utah Seismograph Stations Message Passing System.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___messaging_patterns___pub_sub___x_pub_x_sub.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Extended Publisher-Subscriber<div class="ingroups"><a class="el" href="group___messaging_patterns__chapter.html">Messaging Patterns</a> &raquo; <a class="el" href="group___messaging_patterns___pub_sub.html">Publisher-Subscriber Patterns</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A fully asynchronous publish-subscribe mechanism whereby a forwarder (proxy) relays messages from multiple publishers to multiple subscribers.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Extended Publisher-Subscriber:</div>
<div class="dyncontent">
<div class="center"><img src="group___messaging_patterns___pub_sub___x_pub_x_sub.png" border="0" usemap="#agroup______messaging__patterns______pub__sub______x__pub__x__sub" alt=""/></div>
<map name="agroup______messaging__patterns______pub__sub______x__pub__x__sub" id="agroup______messaging__patterns______pub__sub______x__pub__x__sub">
<area shape="rect" title="A fully asynchronous publish&#45;subscribe mechanism whereby a forwarder (proxy) relays messages from mul..." alt="" coords="208,5,355,45"/>
<area shape="rect" href="group___messaging_patterns___pub_sub.html" title=" " alt="" coords="5,5,160,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_proxy.html">UMPS::Messaging::XPublisherXSubscriber::Proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ZeroMQ proxy to be used in the XPUB/XSUB pattern.  <a href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_proxy_options.html">UMPS::Messaging::XPublisherXSubscriber::ProxyOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for initializing the proxy.  <a href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_proxy_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_publisher.html">UMPS::Messaging::XPublisherXSubscriber::Publisher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ZeroMQ publisher.  <a href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_publisher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_publisher_options.html">UMPS::Messaging::XPublisherXSubscriber::PublisherOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for initializing the publisher in the XPUB/XSUB pattern.  <a href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_publisher_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_subscriber.html">UMPS::Messaging::XPublisherXSubscriber::Subscriber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The subscriber in an extended publisher/subscriber messaging pattern.  <a href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_subscriber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_subscriber_options.html">UMPS::Messaging::XPublisherXSubscriber::SubscriberOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for initializing the subscriber in the extended PUB/SUB pattern.  <a href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_subscriber_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A fully asynchronous publish-subscribe mechanism whereby a forwarder (proxy) relays messages from multiple publishers to multiple subscribers. </p>
<p>Despite its simplicitly the <a class="el" href="group___messaging_patterns___pub_sub___pub_sub.html">Publisher-Subscriber</a> is not sufficient in practice. For real applications, where we may have multiple data sources (e.g., UUSS field instruments telemetered to import boxes and data streams from other networks served through <a href="https://ds.iris.edu/ds/nodes/dmc/">IRIS</a>). Clearly, we will have multiple data publishers. Of course, it is possible to perpetually add a subscriber for each data feed in our applications but this will become cumbersome and difficult to maintain; particularly when a data feed is dropped. What we really want is one-stop shopping. If a subscriber connects to a particular endpoint then it will be able to receive every message in the data feed, i.e., the subscriber need not know the details of every publisher. For this reason, we introduce the extended publisher-subscriber or xPub-xSub. As a rule, even if I were considering a single producer and single consumer application, I would still implement it as a xPub-xSub pattern because experience dictates that even in well-planned applications more publishers always manage to materialize. </p>
<p><br  />
 </p><div class="image">
<img src="xpubxsub.jpg" alt="" width="400cm"/>
<div class="caption">
The extended publisher-subscriber (xPub-xSub) pattern. Here four subscribers receive messages from three publishers.</div></div>
<p> <br  />
</p>
<p>The technology required to make this happen is to introduce a middleman or <em>proxy</em>. The proxy provides a stable endpoint to which publishers send data and subscribers retrieve data. In the parlence of ZeroMQ data goes into the proxy's <em>frontend</em> and data goes out the proxy's backend. </p>
<h1><a class="anchor" id="TopicMessagingPatterns_XPubXSub_Example"></a>
An Example</h1>
<p>There really is not much more to this pattern than what you have already seen in the <a class="el" href="group___messaging_patterns___pub_sub___pub_sub.html#TopicMessagingPatterns_PubSub_Example">An Example</a>. In principle, data is again being sent from producers to subscribers. The main differences are that instead of one publisher we will have three, the number of subscribers is increased from three to four, and there is a proxy. <br  />
</p>
<h2><a class="anchor" id="TopicMessagingPatterns_XPubXSub_Publisher"></a>
The Publisher</h2>
<p>The publisher is like the previous pub-sub publisher. However, it <em>connects</em> to the proxy. In the verbiage of ZeroMQ we <em>bind</em> to <em>stable</em> endpoints. Hence, UMPS views content producers and subscribers as ephemeral and proxies as long-lifetime, stable endpoints. Consequently, your modules will always connect to the uOperator.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;umps/messaging/xPublisherXSubscriber/publisher.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;umps/messaging/xPublisherXSubscriber/publisherOptions.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;umps/messageFormats/text.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;xpubxsub.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>UMPS::Messaging::XPublisherXSubscriber;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> publisher(<span class="keyword">const</span> <span class="keywordtype">int</span> publisherID)</div>
<div class="line">{</div>
<div class="line">    PublisherOptions publisherOptions;</div>
<div class="line">    publisherOptions.setAddress(<span class="stringliteral">&quot;tcp://127.0.0.1:5555&quot;</span>); <span class="comment">// Connect to this address</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group___applications__u_operator.html#ggae30f32e64f53967cac8d851f01602a67a32c73be0cb175da278c8e2af0811b0d1">Publisher</a> publisher;</div>
<div class="line">    publisher.initialize(publisherOptions);</div>
<div class="line">    <span class="comment">// Deal with slow joiner problem.</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(200));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Send messages</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N_MESSAGES; ++i)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="class_u_m_p_s_1_1_message_formats_1_1_text.html">UMPS::MessageFormats::Text</a> textMessage;</div>
<div class="line">        textMessage.<a class="code" href="class_u_m_p_s_1_1_message_formats_1_1_text.html#af7c8aaccbce613095d7d070b7e2462cb">setContents</a>(<span class="stringliteral">&quot;Message number &quot;</span></div>
<div class="line">                              + std::to_string(i + 1)</div>
<div class="line">                              + <span class="stringliteral">&quot; from publisher &quot;</span></div>
<div class="line">                              + std::to_string(publisherID));</div>
<div class="line">        publisher.send(textMessage);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_u_m_p_s_1_1_message_formats_1_1_text_html"><div class="ttname"><a href="class_u_m_p_s_1_1_message_formats_1_1_text.html">UMPS::MessageFormats::Text</a></div><div class="ttdoc">Defines a text-based message. For example, this class would allow you to send the contents of a text ...</div><div class="ttdef"><b>Definition:</b> text.hpp:13</div></div>
<div class="ttc" id="aclass_u_m_p_s_1_1_message_formats_1_1_text_html_af7c8aaccbce613095d7d070b7e2462cb"><div class="ttname"><a href="class_u_m_p_s_1_1_message_formats_1_1_text.html#af7c8aaccbce613095d7d070b7e2462cb">UMPS::MessageFormats::Text::setContents</a></div><div class="ttdeci">void setContents(const std::string &amp;contents) noexcept</div><div class="ttdoc">Sets the contents of a text message.</div></div>
<div class="ttc" id="agroup___applications__u_operator_html_ggae30f32e64f53967cac8d851f01602a67a32c73be0cb175da278c8e2af0811b0d1"><div class="ttname"><a href="group___applications__u_operator.html#ggae30f32e64f53967cac8d851f01602a67a32c73be0cb175da278c8e2af0811b0d1">UMPS::Services::ConnectionInformation::SocketType::Publisher</a></div><div class="ttdeci">@ Publisher</div></div>
</div><!-- fragment --><h2><a class="anchor" id="TopicMessagingPatterns_XPubXSub_Subscriber"></a>
The Subscriber</h2>
<p>The subscriber is exactly like the pub-sub subscriber. In fact, you can use a pub-sub subscriber to connect to the proxy's backend and things will work.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;umps/messaging/xPublisherXSubscriber/subscriber.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;umps/messaging/xPublisherXSubscriber/subscriberOptions.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;umps/messageFormats/text.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;umps/messageFormats/messages.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;umps/messageFormats/staticUniquePointerCast.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;xpubxsub.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>UMPS::Messaging::XPublisherXSubscriber;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> subscriber(<span class="keywordtype">int</span> subscriberID)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Define the message types that the subscriber will receive</span></div>
<div class="line">    <a class="code" href="class_u_m_p_s_1_1_message_formats_1_1_messages.html">UMPS::MessageFormats::Messages</a> messageTypes;</div>
<div class="line">    std::unique_ptr&lt;UMPS::MessageFormats::IMessage&gt; textMessageType</div>
<div class="line">        = std::make_unique&lt;UMPS::MessageFormats::Text&gt; (); </div>
<div class="line">    messageTypes.<a class="code" href="class_u_m_p_s_1_1_message_formats_1_1_messages.html#a6ed03361ef900097e8aa9a7d8b258f4b">add</a>(textMessageType);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define the subscriber options</span></div>
<div class="line">    SubscriberOptions subscriberOptions;</div>
<div class="line">    subscriberOptions.setAddress(<span class="stringliteral">&quot;tcp://127.0.0.1:5556&quot;</span>); <span class="comment">// Connect to this address</span></div>
<div class="line">    subscriberOptions.setMessageTypes(messageTypes); <span class="comment">// Types of messages to get</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize the subscriber</span></div>
<div class="line">    <a class="code" href="group___applications__u_operator.html#ggae30f32e64f53967cac8d851f01602a67a992c4a5b4628d8ebf671cf460254ee81">Subscriber</a> subscriber;</div>
<div class="line">    subscriber.initialize(subscriberOptions);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now retrieve messages</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N_PUBLISHERS*N_MESSAGES; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// The message is read off the wire by ZeroMQ and deserialized</span></div>
<div class="line">        <span class="comment">// by the Text class.</span></div>
<div class="line">        <span class="keyword">auto</span> message = subscriber.receive(); <span class="comment">// Blocks until message is received</span></div>
<div class="line">        <span class="comment">// Convert the message so we can look at the contents</span></div>
<div class="line">        <span class="keyword">auto</span> textMessage</div>
<div class="line">            = static_unique_pointer_cast&lt;UMPS::MessageFormats::Text&gt;</div>
<div class="line">              (std::move(message));</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;SubscriberID: &quot;</span> &lt;&lt; subscriberID &lt;&lt; <span class="stringliteral">&quot; received: &quot;</span> </div>
<div class="line">                  &lt;&lt; textMessage-&gt;<a class="code" href="class_u_m_p_s_1_1_message_formats_1_1_text.html#a6d5d6552bd82bc54880175427a6fd260">getContents</a>() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_u_m_p_s_1_1_message_formats_1_1_messages_html"><div class="ttname"><a href="class_u_m_p_s_1_1_message_formats_1_1_messages.html">UMPS::MessageFormats::Messages</a></div><div class="ttdoc">This is a container for holding multiple (unique) message formats.</div><div class="ttdef"><b>Definition:</b> messages.hpp:16</div></div>
<div class="ttc" id="aclass_u_m_p_s_1_1_message_formats_1_1_messages_html_a6ed03361ef900097e8aa9a7d8b258f4b"><div class="ttname"><a href="class_u_m_p_s_1_1_message_formats_1_1_messages.html#a6ed03361ef900097e8aa9a7d8b258f4b">UMPS::MessageFormats::Messages::add</a></div><div class="ttdeci">void add(const std::unique_ptr&lt; IMessage &gt; &amp;message)</div><div class="ttdoc">Add the message type to the container.</div></div>
<div class="ttc" id="aclass_u_m_p_s_1_1_message_formats_1_1_text_html_a6d5d6552bd82bc54880175427a6fd260"><div class="ttname"><a href="class_u_m_p_s_1_1_message_formats_1_1_text.html#a6d5d6552bd82bc54880175427a6fd260">UMPS::MessageFormats::Text::getContents</a></div><div class="ttdeci">std::string getContents() const noexcept</div></div>
<div class="ttc" id="agroup___applications__u_operator_html_ggae30f32e64f53967cac8d851f01602a67a992c4a5b4628d8ebf671cf460254ee81"><div class="ttname"><a href="group___applications__u_operator.html#ggae30f32e64f53967cac8d851f01602a67a992c4a5b4628d8ebf671cf460254ee81">UMPS::Services::ConnectionInformation::SocketType::Subscriber</a></div><div class="ttdeci">@ Subscriber</div></div>
</div><!-- fragment --><h2><a class="anchor" id="TopicMessagingPatterns_XPubXSub_Proxy"></a>
The Proxy</h2>
<p>The proxy is a new concept. What this thread does is simply take data from the input port (frontend) and stick it on output port (backend). Its a worker whose job is to simply take items from one conveyer belt and put them on an adjacent conveyer belt. Surprisingly, this remarkably simple mechanism seems sufficient for many broadcast applications.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;umps/messaging/xPublisherXSubscriber/proxy.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;umps/messaging/xPublisherXSubscriber/proxyOptions.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>UMPS::Messaging::XPublisherXSubscriber;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> proxy()</div>
<div class="line">{</div>
<div class="line">    ProxyOptions proxyOptions;</div>
<div class="line">    <span class="comment">// Data flows from frontend to backend</span></div>
<div class="line">    proxyOptions.setFrontendAddress(<span class="stringliteral">&quot;tcp://127.0.0.1:5555&quot;</span>); <span class="comment">// Publishers connect here</span></div>
<div class="line">    proxyOptions.setBackendAddress(<span class="stringliteral">&quot;tcp://127.0.0.1:5556&quot;</span>); <span class="comment">// Subscribers connect here</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the proxy</span></div>
<div class="line">    <a class="code" href="class_proxy.html">Proxy</a> proxy;</div>
<div class="line">    proxy.initialize(proxyOptions);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Run the proxy in a separate thread</span></div>
<div class="line">    <span class="keyword">auto</span> proxyThread = std::thread(&amp;<a class="code" href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_proxy.html#aa3d422294832c1ad1cb3761ba78b4d88">Proxy::start</a>, &amp;proxy);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Main thread sleeps a bit</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::seconds {3});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The main thread tells the proxy to shut down</span></div>
<div class="line">    proxy.stop();</div>
<div class="line">    proxyThread.join();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_proxy_html"><div class="ttname"><a href="class_proxy.html">Proxy</a></div><div class="ttdoc">This is the intermediary that allows communication between a client and a backend service.</div></div>
<div class="ttc" id="aclass_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_proxy_html_aa3d422294832c1ad1cb3761ba78b4d88"><div class="ttname"><a href="class_u_m_p_s_1_1_messaging_1_1_x_publisher_x_subscriber_1_1_proxy.html#aa3d422294832c1ad1cb3761ba78b4d88">UMPS::Messaging::XPublisherXSubscriber::Proxy::start</a></div><div class="ttdeci">void start()</div><div class="ttdoc">Starts the proxy.</div></div>
</div><!-- fragment --><p>Notice that the proxy is running as another thread that must be started and stopped. This is because the proxy is supposed to stay up indefinitely. In general, you will not have to explicitly think about this since the uOperator will be responsible for keeping these proxies alive and open. All you will have to do is connect via the extended publisher or extended subscriber.</p>
<h2><a class="anchor" id="TopicMessagingPatterns_XPubXSub_ExampleDriver"></a>
The Driver</h2>
<p>Lastly, the driver code that launches this example. We create seven threads - three publishers and four subscribers. The subscribers connect first then will block until a message is received. Then the publishers are started. Again, this is a brittle code since we are specifying a priori the number of messages. Therefore, the producer code must contend with the slow joiner problem</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;xpubxsub.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create a proxy thread</span></div>
<div class="line">    <span class="keyword">auto</span> proxyThread = std::thread(proxy);</div>
<div class="line">    <span class="comment">// Give proxy a moment to get up and running</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds {500});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Subscribers connect first - so as not to miss messages</span></div>
<div class="line">    <span class="keyword">auto</span> subscriberThread1 = std::thread(subscriber, 1);</div>
<div class="line">    <span class="keyword">auto</span> subscriberThread2 = std::thread(subscriber, 2);</div>
<div class="line">    <span class="keyword">auto</span> subscriberThread3 = std::thread(subscriber, 3); </div>
<div class="line">    <span class="keyword">auto</span> subscriberThread4 = std::thread(subscriber, 4);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Publisher connects and lets it rip</span></div>
<div class="line">    <span class="keyword">auto</span> publisherThread1 = std::thread(publisher, 1);</div>
<div class="line">    <span class="keyword">auto</span> publisherThread2 = std::thread(publisher, 2);</div>
<div class="line">    <span class="keyword">auto</span> publisherThread3 = std::thread(publisher, 3);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait for threads to finish</span></div>
<div class="line">    proxyThread.join();</div>
<div class="line">    subscriberThread1.join();</div>
<div class="line">    subscriberThread2.join();</div>
<div class="line">    subscriberThread3.join();</div>
<div class="line">    subscriberThread4.join();</div>
<div class="line">    publisherThread1.join();</div>
<div class="line">    publisherThread2.join();</div>
<div class="line">    publisherThread3.join();</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="TopicMessagingPatterns_XPubXSub_Conclusion"></a>
Summary</h2>
<p>In closing, it should be clear that the xPub-xSub paradigm requires marginally more effort than its naive publisher-subscriber counterpart. However, do not undererestimate the xPub-xSub. At UUSS this is the mechanism by which we move all of our data packets, all of our probability packets, and STA/LTA packets, as well as all of our picks, events, and module heartbeats. And the computational cost on the uOperator hub is small. Long story short, when it comes to solving the broadcast problem, you will be hard-pressed to find a more flexible and scalable approach than the xPub-xSub. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Mar 17 2023 23:05:22 for UMPS by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
